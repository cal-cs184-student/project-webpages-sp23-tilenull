<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Path Tracer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
<h1 align="middle">Project 3-2: Additional Features to PathTracer</h1>
<h2 align="middle">Shawn Zhao, Jason Gong</h2>

<!-- Add Website URL -->
<h2 align="middle">Website URL: <a href="https://cal-cs184-student.github.io/project-webpages-sp23-tilenull/proj3-2/index.html">https://cal-cs184-student.github.io/project-webpages-sp23-tilenull/proj3-2/index.html</a></h2>

<br><br>

<h2 align="middle">Overview</h2>
<p>
    In this project, we learned how to ray trace lights and render shading with light sources. We applied concepts from class such as ray-scene intersection, BVH trees, and direct/indirect lighting. We finally were able to render realistic images with proper color, and it was interesting to see our progress even in this project itself, as we went from rendering scenes to incorporating light sources into the shading.
</p>
<br>

<h2 align="middle">Part 2: Microfacet Material</h2>

<p>
  In this part, we implemented BVH construction. To construct our BVH we first loop over the primitives and enlarge the bounding box by the bounding box of each primitive, while also collecting some useful numbers to determine our heuristic with, the minimum and maximum centroids across the x, y, and z axes and the average of the centroids. Our heuristic is to pick the axis with the largest range and use the centroid of this axis as the splitting point for our left and right nodes. The idea is that the axis with the largest range will likely contain the most primitives spread out across it and taking the average splits them evenly. We calculate the range from the minimums and maximums and depending on the axis we choose we split the primitives using std::partition based on the .x, .y, or .z of the overall average centroid. We then recursively build the BVH by assigning the left and right nodes of the node to recursive calls on the partitioned halves of the primitives vector. The base case is if there are less than max_leaf_size primitives, then the node is a leaf and the left and right nodes are null.
  <br><br>
  Shown below are images with normal shading for a few large .dae files were rendered with BVH acceleration.
</p>
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/maxplanck.png" align="middle" width="480px"/>
        <figcaption>maxplanck.dae</figcaption>
      </td>
      <td>
        <img src="images/CBLucy.png" align="middle" width="480px"/>
        <figcaption>CBlucy.dae</figcaption>
      </td>
    </tr>
    <tr align="center">
      <td>
        <img src="images/bunny.png" align="middle" width="480px"/>
        <figcaption>bunny.dae</figcaption>
      </td>
      <td>
        <img src="images/beast.png" align="middle" width="480px"/>
        <figcaption>beast.dae</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<p>
  Rendering cow.dae on 8 threads at 800x600 without BVH acceleration took 54.1692s with average 729.208034 intersection tests per ray. With BVH acceleration it took only 0.0749s with 2.131698 intersection tests per ray. Beetle.dae took 82.2256s with 1025.578253 intersection tests per ray vs 0.0721s with 1.311082 intersection tests per ray. Bench.dae took 953.2370s with 10727.354107 intersection tests per ray vs 0.0631s with 0.448200 intersection tests per ray. BVH acceleration greatly speeds up the process of rendering by allowing us to ignore rays that do not intersect the bounding boxes instead of checking every primitive individually. Our heuristic allows us to efficiently group the primitives in bounding boxes such that we can try to ignore as many primitives as possible per ray. The performance gains are more and more apparent with more complex geometries, which took more intersection tests more ray without BVH acceleration, allowing us to render some files that were not possible before. 


</body>
</html>